# ⚙️ RaceController 문제 분석 및 리팩토링

`RaceController`에 대한 피드백이 들어왔다.
피드백 내용을 참고하여 `RaceController`의 문제점을 정리해보았다.

## ✅ 문제점

- 컨트롤러를 테스트하고 있다. 미션 요구사항은 도메인에 대해서 단위 테스트 하는 것이다.
- 그만큼 `RaceController`는 컨트롤러의 역할을 하고 있지 않다는 뜻이다.
- 즉, 컨트롤러의 역할이라고 하기엔 도메인 로직의 비중이 많다.
- 내부에 `getRandomNumber` 로직이 있어서 해당 함수를 모킹하고 있다.
  - 현재 `RaceController` 테스트가 거의 통합 테스트에 가깝다. (이는 단위 테스트라고 볼 수 없다.)
  - 모킹 함수를 사용하지 말라는 요구사항에 위반하기 때문에, `getRandomNumber`를 더 상위 객체로 빼줄 필요가 있다.

## ✅ 고민

그렇다면 도메인과 뷰를 제대로 분리하려면 어떻게 해야할까?
내가 제일 고민했던 부분은 다음과 같다.

- 만약 `RaceController`를 `Race`라는 도메인으로 정의한다면, 도메인 간의 의존성은 어떻게 해결할 것인가?
  - Car를 전적으로 의존하고 있어, 도메인 간 결합도가 높다.
  - 그렇기 때문에 `Race`라는 도메인으로 구현하는 것도 애매하다.
  - 이런 `Race`라는 객체는 도메인도 뷰도 컨트롤러도 아닌 새로운 계층에 있어야 한다고 생각했다.
    (MVC의 단점 중 하나라고 생각함. 도메인과 도메인 간의 결합이 있을 수도 있고, 하나의 도메인이 다른 도메인에 의존하는 경우가 있기 때문임.)
- 도메인과 뷰 로직이 섞여 있는 부분은 어떻게 분리할 것인가? 사실 게임 로직 상 떼어낼 수 없는 구조인데.

## ✅ 해결책

컨트롤러는 도메인과 뷰의 상호작용 역할을 해주어야 한다고 생각했다.
그렇기 때문에 `GameController`에서는 로직 상 떼어낼 수 없는 뷰 부분을 관리하고, 최대한 다른 도메인 모듈을 가져다 쓸 수 있도록 리팩토링 했다.
그리고 `RaceController`에서 도메인 로직이라고 생각했던 부분을 하나의 모듈 단위로 하여 유틸 함수로 분리하였다.

이렇게 되면 다음과 같은 장점이 있다.

- 단위 테스트 하기 더욱 용이해짐.
- `getRandomNumber`를 모킹하지 않아도 됨. (`jest.fn()` 제거)
- 도메인 로직을 컨트롤러에서 빼냄으로써, 게임 전체 로직을 담당하는 컨트롤러(`GameController`)의 역할에 집중할 수 있음. (응집도⬆️)

하지만 이 방식에도 고민이 있었다.

- 사실 유틸 함수는 특정 작업을 수행하기 위해 특히, 재사용성을 고려하여 분리하는 독립 실행 함수이다.
- 근데, 지금 `getWinners`와 `getMaxCount`는 무조건 자동차 인스턴스 배열이 인자로 주입되어야 한다.
- 즉, `Car` 객체에 의존하고 있다는 것인데, 이게 과연 최선의 방식일까 싶다.
- `RaceController`를 테스트 하는 방식보다는 훨씬 단위 테스트가 수월해졌기 때문에 전보다는 나은 것 같다는 생각이 든다. 물론 개인적인 생각이다.

아래 `GameController`을 보면 간략하게 도메인과 뷰가 어떤식으로 호출되고 결합되었는지 알 수 있다.

```js
class GameController {
  async play() {
    const { carNames, tryCount } = await this.#getValidatedInputs();
    const cars = carNames.map((carName) => new Car(carName)); // Domain
    this.#playRace(cars, tryCount);
  }

  #playRace(cars, tryCount) {
    // 경기 시작 메시지 출력 - View
    // 시도 횟수만큼 경기 진행 - playRound 내부 함수 호출
    // 최종 우승자 출력 - Domain + View 결합
  }

  #playRound(cars) {
    // 각 라운드 경기 진행
    // 자동차 별 랜덤 숫자 생성 및 move 메서드 호출 - Domain + Domain 결합
    // 현 라운드의 점수(전진 거리) 출력 - View
  }

  async #getValidatedInputs() {
    // 입력 및 유효성 검증 - View + Domain 결합
    // 자동차 이름 배열, 시도 횟수 반환
  }
}
```

`GameController`를 보면 `play()` 메서드는 경기 자체를 시작하는 함수로 `자동차 이름들`과 `시도 횟수`를 입력 받는다.

여기서 `시도 횟수`의 경우에도 기존에는 `RaceController` 내부에서 관리하다가 `GameController` 옮기게 되었다.
`시도 횟수`의 경우에는 경기의 전체 라운드 수를 결정하는 부분이기 때문에 `Car` 객체에도 존재할 수 없고, 유틸 함수에 넣기에는 적절하지 못하다고 판단했다.
만약 `Race`라는 객체가 따로 있었다면 거기서 관리했겠지만, `Race`라는 객체 자체가 존재하지 않기 때문에 컨트롤러의 역할이라고 판단하여 위와 같이 구현하게 되었다.

## ✅ 확장성

시지프가 페어 호이초이에게 남긴 [동일한 cars로 replay 버튼이 생긴다면 어떻게 대응할 것인가?](https://github.com/woowacourse/javascript-racingcar/pull/347#discussion_r1954453352)라는 질문을 보게 되었다.
<br/>이 부분에 있어서도 한 번 생각해보면 좋을 것 같아서 확장성을 고려해서 리팩토링을 진행했다.

위 `GameController`를 보면 각 자동차들에 대한 인스턴스를 `play()` 내부에서 선언해두었는데, 이렇게 되면 경기 전체 로직을 실행하는 `playRace()` 메서드와 분리할 수 있다.
<br/>기존의 `RaceController`를 사용했을 때는 해당 컨트롤러 내부에서 자동차들에 대한 인스턴스를 생성하고 있었기 때문에, 만약 `replay` 버튼이 생길 경우에는 매번 인스턴스를 생성해야 하는 문제가 발생했을 것이다.
<br/>위와 같이 리팩토링한 후에는, `playRace()` 만 재실행해주면 되기 때문에 설계에 있어 훨씬 유연한 구조가 될 수 있다.

## ✅ 추가 고민

✔️ `cars`를 `GameController`의 전역 필드로 빼는 것이 더 나은 방식일까? 아니면 지금처럼 인자로 넣어주는 것이 더 효율적인 방식일까?

✔️ `GameController`는 도메인과 뷰를 관리하는 역할을 하는데, 어찌되었든 결합이 된다는 것이다. 그렇기에 기능의 많아질수록 컨트롤러가 비대해지는 것은 당연한 일이다. 그럴 땐 결합도를 줄이려면 어떻게 해야 할까?

- 사실 지금도 `import`가 너무 많다고 느끼고 있다.
- 컨트롤러를 더 분리하거나 새로운 계층을 도입하는 것이 더 좋을 것 같다는 생각이 들었다.
- 그렇기 때문에 설계에 있어서 더 안정적이고 유지보수성 좋은 디자인 패턴이 많이 나오는 것 같다.
- `MVC`는 확실히 크고 복잡한 프로젝트에서는 한계가 있는 디자인 패턴인 것 같다고 생각한다.
